course_title: Intro to Unix for Data Science
course_description: >-
  The Unix command line has survived and thrived for almost fifty years because
  it lets people to do complex things with just a few keystrokes. Sometimes
  called "the duct tape of programming", it helps users combine existing
  programs in new ways, automate repetitive tasks, and run programs on clusters
  and clouds that may be halfway around the world. This lesson will introduce
  its key elements and show you how to use them efficiently.
programming_language: python
chapters:
  - chapter_title: Why the Command Line?
    chapter_description: >-
      Three-minute video explaining that the command line is an interface to the
      operating system, just like the GUIs that learners are probably familiar
      with, but because it's textual, it supports history and automation.
    exercises:
      - type: MultipleChoiceExercise
        title: How are they connected?
        content: >-
          What is the relationship between the graphical file explorer that most
          people use and the shell?

          - The file explorer lets you view and edit files, while the shell lets
          you run programs.

          - The file explorer is built on top of the shell.

          - The shell is part of the operating system, while the file explorer
          is separate.

          - They are both interfaces for issuing commands to the operating
          system.
      - type: MultipleChoiceExercise
        title: What is a shell?
        content: |-
          What kind of thing is a shell?
          - a program
          - an operating system
          - a text-only mode of the file explorer
  - chapter_title: Core Commands
    chapter_description: >-
      - `whoami`

      - `pwd` and a comment on how cryptic commands are

      - interpreting output of `pwd`: folders containing folders

      - `ls` (depends on a certain file setup)

      - `cat`

      - Editing text files (use `nano` and explain how a shell can have multiple
      personalities)

      - Text vs. binary files

      - `cp`

      - `mv`

      - `rm`

      - `mkdir` and `rmdir`
    exercises:
      - type: MultipleChoiceExercise
        title: Absolute and Relative Paths
        content: >-
          Starting from `/Users/jasmine/data/`, which of the following commands
          could Jasmine use to navigate to  `/Users/jasmine`?


          1. `cd .`

          2. `cd /`

          3. `cd /home/jasmine`

          4. `cd ../..`

          5. `cd ~`

          6. `cd home`

          7. `cd ~/data/..`

          8. `cd`

          9. `cd ..`
      - type: MultipleChoiceExercise
        title: Relative Path Resolution
        content: >-
          Using the filesystem diagram below, if `pwd` displays
          `/Users/jasmine`, what will `ls ../backup` display?


          1.  `../backup: No such file or directory`

          2.  `2012-12-01 2013-01-08 2013-01-27`

          3.  `2012-12-01/ 2013-01-08/ 2013-01-27/`

          4.  `original report_final report_sub`
      - type: NormalExercise
        title: Listing Options
        content: >-
          Given the filesystem shown below, if `pwd` displays `/Users/backup`,
          and `-r` tells `ls` to display things in reverse order, what command
          will display:


          ```

          report_sub/ report_final/ original/

          ```


          1.  `ls pwd`

          2.  `ls -r -F`

          3.  `ls -r -F /Users/backup`

          4.  Either #2 or #3 above, but not #1.
      - type: NormalExercise
        title: Combining Listing Options
        content: >-
          The command `ls -R` lists the contents of directories recursively,
          i.e., lists their sub-directories, sub-sub-directories, and so on in
          alphabetical order at each level. The command `ls -t` lists things by
          time of last change, with most recently changed files or directories
          first. In what order does `ls -R -t` display things?


          1. All files and then all directories in order of last change.

          2. All directories in alphabetical order followed by all files in
          order of last change.

          3. Directories alphabetically by level, and their contents in order of
          last change.

          4. None of the above.
      - type: NormalExercise
        title: Editing a File
        content: >-
          Use `nano` to create a file called `workplan.txt` in the directory
          `personal` that contains the following text:


          ```

          Step 1: choose problem.

          Step 2: think really hard.

          Step 3: profit!

          ```


          Make sure there are no trailing spaces at the ends of lines, or blank
          lines at the end of the file.
      - type: NormalExercise
        title: Backing Up Files
        content: >-
          Create a new directory called `backup` below your home directory, and
          then copy the files `biography.txt` and `thesis.txt` into that
          directory.  When you are done, the command `ls backup` should show
          you:


          ```

          biography.txt .   thesis.txt

          ```
      - type: MultipleChoiceExercise
        title: Special Directory Names
        content: >-
          What is the difference between `cd ./..` and `cd ../.` ?


          1. Both move you up one directory.

          2. The first moves you up one directory, while the second leaves you
          where you are.

          3. The first leaves you where you are, while the second moves you up
          one directory.

          4. Both leave you where you are.
      - type: NormalExercise
        title: Moving and Copying
        content: >-
          What is the output of the closing `ls` command in the sequence shown
          below?


          ```

          $ pwd

          /Users/jasmine/data


          $ ls

          mortality.dat


          $ mkdir old

          $ mv mortality.dat old

          $ cp old/mortality.dat ../mortality-saved.dat

          $ ls

          ```


          1. `mortality-saved.dat old`

          2. `old`

          3. `mortality.dat old`

          4. `mortality-saved.dat`
      - type: MultipleChoiceExercise
        title: Copy With Multiple Filenames
        content: >-
          ```

          $ ls -F

          analysis/  births/  home-ownership.txt  mortality.txt  temp/


          $ cp mortality.txt home-ownership.txt births

          ```


          1. Produces an error message.

          2. Makes backup copies of both files and the entire `births`
          directory.

          3. Copies the two files to the `births` directory.
      - type: NormalExercise
        title: More Copying With Multiple Filenames
        content: >-
          Given your answer to the previous exercise, what would happen if you
          ran the following command instead:


          ```

          $ cp mortality.txt births home-ownership.txt

          ```


          1. Produce an error message.

          2. Copy `mortality.txt` to `births`.

          3. Copy the two files to the `births` directory.
      - type: NormalExercise
        title: Moving to the Current Folder
        content: >-
          You are in the directory `~/analyzed`, and the directory `~/raw`
          contains a file called `output.txt`. Run a single command to move the
          file to the `analyzed` directory.  (Remember that `~` is a shorthand
          for your home directory.)
  - chapter_title: Manipulating Data
    chapter_description: |-
      - `head` and `tail`
      - `cut`
      - `grep` (with very simple patterns)
      - `sort`
      - `uniq`
      - `nl`
      - `man`
    exercises:
      - type: NormalExercise
        title: Selecting Dates and Names
        content: >-
          Write a command that selects *only* the date and name field from each
          record in `mortality.txt`.
      - type: NormalExercise
        title: Selecting Specific Years
        content: >-
          Write a command that selects *only* the data from 2000, 2005, and 2010
          from `mortality.txt`.
      - type: MultipleChoiceExercise
        title: Removing Duplicates from Multiple Files
        content: >-
          You want to remove duplicate lines from multiple files with one
          command, so you write `uniq births.txt mortality.txt`. What actually
          happens?


          1. The command removes any duplicate lines that occur in either
          `births.txt` or `mortality.txt`.

          2. The command removes duplicate lines in `births.txt` and
          `mortality.txt` independently.

          3. The command removes duplicate lines in `births.txt` and
          `mortality.txt`, *and* removes the first line(s) of `second.txt` if
          they duplicate the last line(s) of `births.txt`.

          4. The command removes duplicate lines from `births.txt` and stores
          the result in `mortality.txt`.
      - type: NormalExercise
        title: Unintended Consequences
        content: >-
          Given your answer to the previous question, what happens if you run
          the command `uniq births.txt births.txt`?


          1. It removes duplicate lines from `births.txt` and stores the result
          in `births.txt`.

          2. It erases the contents of `births.txt`.

          3. It produces no output, because every line of input now appears to
          be duplicated.
      - type: NormalExercise
        title: Sorting Multiple Files
        content: >-
          What does `sort births.txt mortality.txt` do?


          1. It sorts the contents of `births.txt` and then the contents of
          `mortality.txt` separately.

          2. It sorts the merged contents of `births.txt` and `mortality.txt` as
          if they were one file.

          3. It sorts `births.txt` and writes the output to `mortality.txt`
          (overwriting whatever was there).

          4. None of the above.
      - type: NormalExercise
        title: Suppressing Headers
        content: >-
          By default, `tail` displays the names of the files it is tailing when
          it is asked to tail multiple files. Use `man tail` to examine its
          documentation (or type `man tail` into your favorite search engine)
          and then write a single command that displays the last line of
          `birth.txt` and `mortality.txt` *without* filename headers.
  - chapter_title: Reusing and Combining Commands
    chapter_description: |-
      - `history`
      - re-executing with `!name` and `!number`
      - output redirection with `>`
      - why this is a clumsy way to combine multiple commands
      - using `|`
    exercises:
      - type: NormalExercise
        title: Unique Dates
        content: >-
          Using pipes to combine two or more basic commands, write a single-line
          command that displays unique dates in `mortality.txt`.
      - type: NormalExercise
        title: Counting Causes
        content: >-
          Using pipes to combine two or more basic commands, write a single-line
          command that displays a list of causes of death in `mortality.txt`
          sorted in order of decreasing frequency. Display the frequency as well
          as the cause.
      - type: NormalExercise
        title: Unique Causes
        content: >-
          Using pipes to combine two or more basic commands, write a single-line
          command that lists unique causes of death in `mortality.txt`, i.e.,
          causes that only occur once.  Display only the frequency, *not* the
          cause.
      - type: NormalExercise
        title: File Lengths
        content: >-
          Use `man wc` to find out how to count the number of lines in one or
          more files, and then use it in a pipe to list `births.txt`,
          `mortality.txt`, and `accidents.txt` from fewest to greatest number of
          lines.
      - type: NormalExercise
        title: Analyzing Pipelines
        content: >-
          A file called `animals.txt` contains the following data:


          ```

          2012-11-05,deer

          2012-11-05,rabbit

          2012-11-05,raccoon

          2012-11-06,rabbit

          2012-11-06,deer

          2012-11-06,fox

          2012-11-07,rabbit

          2012-11-07,bear

          ```


          What text passes through each of the pipes and the final redirect in
          the pipeline below?


          ```

          $ cat animals.txt | head -n 5 | tail -n 3 | sort -r > final.txt

          ```
      - type: MultipleChoiceExercise
        title: Which Pipeline?
        content: >-
          `animals.txt` contains data formatted as follows:


          ```

          2012-11-05,deer

          2012-11-05,rabbit

          2012-11-05,raccoon

          2012-11-06,rabbit

          ...

          ```


          What command would you use to produce a table that shows the total
          count of each type of animal in the file?


          1.  `grep {deer, rabbit, raccoon, deer, fox, bear} animals.txt | wc
          -l`

          2.  `sort animals.txt | uniq -c`

          3.  `sort -t, -k2,2 animals.txt | uniq -c`

          4.  `cut -d, -f 2 animals.txt | uniq -c`

          5.  `cut -d, -f 2 animals.txt | sort | uniq -c`

          6.  `cut -d, -f 2 animals.txt | sort | uniq -c | wc -l`
  - chapter_title: Building New Commands
    chapter_description: >-
      - putting fixed commands in a shell script

      - executing scripts with `bash scriptname`

      - making scripts executable with `chmod` (hate to introduce this in
      passing, but...)

      - handling multiple filenames with `$@`

      - using wildcards `*` and `?`

      - using `history | tail > file.sh` to start a shell script
    exercises:
      - type: NormalExercise
        title: Using Wildcards in Pipes
        content: >-
          We want to find the three files in our current directory which have
          the least number of lines. Which command listed below would work?


          1. `wc -l * > sort -n > head -n 3`

          2. `wc -l * | sort -n | head -n 1-3`

          3. `wc -l * | head -n 3 | sort -n`

          4. `wc -l * | sort -n | head -n 3`
      - type: NormalExercise
        title: Removing Unneeded Files
        content: >-
          Suppose you want to delete your processed data files, and only keep
          your raw files and processing script to save storage. The raw files
          end in `.dat` and the processed files end in `.txt`. Which of the
          following would remove all the processed data files, and *only* the
          processed data files?


          1. `rm ?.txt`

          2. `rm *.txt`

          3. `rm * .txt`

          4. `rm *.*`
      - type: NormalExercise
        title: Wildcard Expressions
        content: >-
          The wildcard `[xy]` matches *either* a single `x` or a single `y`
          character. Fill in the blank in the expression below to list only the
          files from 2012 and 2013.


          ```

          ls ____.dat

          ```
      - type: NormalExercise
        title: Reproducing Your Work
        content: >-
          Fill in the blanks in the shell script `dates.sh` to select unique
          dates from the file `mortality.txt`.
      - type: NormalExercise
        title: Generalizing Your Work
        content: >-
          Fill in the blanks in the shell script `dates.sh` to select unique
          dates from a single file whose name is given as the script's sole
          command-line argument.
      - type: NormalExercise
        title: Diagnosis
        content: >-
          When you run this command:


          ```

          head -10 | tail -3 mortality.txt

          ```


          it prints the last 3 lines of `mortality.txt` and then hangs (i.e., it
          doesn't give you a fresh shell prompt for writing more commands). 
          Why?
  - chapter_title: Next Steps
    chapter_description: |-
      - quick summary of what's been learned
      - the Unix philosophy: lots of little tools combined in ad hoc ways
      - Noble's Rules for laying out projects (and why)
      - pointer to the second course (loops, finding files, etc.)
    exercises:
      - type: NormalExercise
        title: Tidying Up
        content: >-
          Using whatever commands you want, reorganize this project to follow
          the structure laid out in Noble's Rules. Run the command `bin/check`
          to see what's out of place.
